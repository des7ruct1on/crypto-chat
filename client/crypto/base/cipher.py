from abc import ABC, abstractmethod
from typing import Optional, Callable
import os
import sys
import time
from colorama import Fore, Style, init
from crypto.base.modes import PaddingMode, CipherMode

init()


class SymmetricCipher(ABC):
    """üîí –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã—Ö —à–∏—Ñ—Ä–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –≤–∏–∑—É–∞–ª—å–Ω—ã–º –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ–º"""

    ALLOWED_KEY_SIZES = [16]

    def __init__(self, key: bytes):
        self._print_banner()
        self._validate_key(key)
        self.key = key
        self._print_success(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —à–∏—Ñ—Ä —Å –∫–ª—é—á–æ–º: {self._format_key(key)}")

    def _print_banner(self):
        """–í—ã–≤–æ–¥–∏—Ç —Å—Ç–∏–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫"""
        print(Fore.BLUE + "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
        print(Fore.BLUE + "‚ïë" + Fore.CYAN + "       –°–ò–ú–ú–ï–¢–†–ò–ß–ù–´–ô –®–ò–§–†       " + Fore.BLUE + "     ‚ïë")
        print(Fore.BLUE + "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" + Style.RESET_ALL)

    def _print_success(self, message: str):
        """–í—ã–≤–æ–¥–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ"""
        print(Fore.GREEN + "‚úì " + message + Style.RESET_ALL)

    def _print_warning(self, message: str):
        """–í—ã–≤–æ–¥–∏—Ç –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ"""
        print(Fore.YELLOW + "‚ö† " + message + Style.RESET_ALL)

    def _print_error(self, message: str):
        """–í—ã–≤–æ–¥–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ"""
        print(Fore.RED + "‚úó " + message + Style.RESET_ALL)

    def _format_key(self, key: bytes) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∫–ª—é—á –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞"""
        return " ".join(f"{b:02x}" for b in key)

    def _animate_loading(self, message: str):
        """–ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏"""
        print(Fore.MAGENTA + "‚åõ " + message + Style.RESET_ALL, end='')
        sys.stdout.flush()
        for _ in range(3):
            time.sleep(0.3)
            print(".", end='')
            sys.stdout.flush()
        print()

    def _validate_key(self, key: bytes):
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–ª—é—á–∞ —Å –≤–∏–∑—É–∞–ª—å–Ω—ã–º –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ–º"""
        self._animate_loading("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–∞")

        if len(key) not in self.ALLOWED_KEY_SIZES:
            self._print_error(f"–ù–µ–≤–µ—Ä–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–ª—é—á–∞: {len(key)} –±–∞–π—Ç. –î–æ–ø—É—Å—Ç–∏–º—ã–µ: {self.ALLOWED_KEY_SIZES}")
            raise ValueError(f"Invalid key size: {len(key)} bytes. Allowed: {self.ALLOWED_KEY_SIZES}")

        if all(b == 0 for b in key):
            self._print_error("–û–±–Ω–∞—Ä—É–∂–µ–Ω —Å–ª–∞–±—ã–π –∫–ª—é—á: –Ω—É–ª–µ–≤—ã–µ –±–∞–π—Ç—ã –Ω–µ –¥–æ–ø—É—Å–∫–∞—é—Ç—Å—è")
            raise ValueError("Weak key detected: all-zero bytes are not allowed.")

        self._print_success("–ö–ª—é—á –ø—Ä–æ—à–µ–ª –≤–∞–ª–∏–¥–∞—Ü–∏—é")

    def _generate_iv(self) -> bytes:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π"""
        self._animate_loading("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏")
        iv = os.urandom(self.BLOCK_SIZE)
        self._print_success(f"–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω IV: {self._format_key(iv)}")
        return iv

    def _pad_data(self, data: bytes, mode: PaddingMode) -> bytes:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ padding'–∞ —Å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π"""
        pad_len = self.BLOCK_SIZE - (len(data) % self.BLOCK_SIZE)
        if pad_len == 0:
            pad_len = self.BLOCK_SIZE

        self._print_warning(f"–î–æ–±–∞–≤–ª–µ–Ω–∏–µ padding'–∞ ({mode.name}): {pad_len} –±–∞–π—Ç")

        if mode == PaddingMode.ZEROS:
            padding = bytes([0] * pad_len)
        elif mode == PaddingMode.ANSI_X923:
            padding = bytes([0] * (pad_len - 1) + [pad_len])
        elif mode == PaddingMode.PKCS7:
            padding = bytes([pad_len] * pad_len)
        elif mode == PaddingMode.ISO_10126:
            padding = os.urandom(pad_len - 1) + bytes([pad_len])
        else:
            self._print_error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º padding'–∞: {mode}")
            raise ValueError(f"Unknown padding mode: {mode}")

        return data + padding

    def _unpad_data(self, data: bytes, mode: PaddingMode) -> bytes:
        """–£–¥–∞–ª–µ–Ω–∏–µ padding'–∞ —Å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π"""
        if len(data) == 0:
            return b''

        if len(data) % self.BLOCK_SIZE != 0:
            self._print_error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è padding'–∞")
            raise ValueError("Invalid data length for removing padding")

        self._print_warning(f"–£–¥–∞–ª–µ–Ω–∏–µ padding'–∞ ({mode.name})")

        if mode == PaddingMode.ZEROS:
            i = len(data) - 1
            while i >= 0 and data[i] == 0:
                i -= 1
            return data[:i + 1] if i >= 0 else b''

        elif mode in (PaddingMode.ANSI_X923, PaddingMode.PKCS7, PaddingMode.ISO_10126):
            pad_len = data[-1]
            if pad_len == 0 or pad_len > self.BLOCK_SIZE:
                if pad_len == 0:
                    return data
                self._print_error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ padding'–∞")
                raise ValueError("Invalid padding value")

            if mode == PaddingMode.PKCS7:
                for i in range(len(data) - pad_len, len(data)):
                    if data[i] != pad_len:
                        if all(b != pad_len for b in data[-pad_len:-1]):
                            return data
                        self._print_error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π PKCS7 padding")
                        raise ValueError("Invalid PKCS7 padding")

            elif mode == PaddingMode.ANSI_X923:
                for i in range(len(data) - pad_len, len(data) - 1):
                    if data[i] != 0:
                        return data

            return data[:-pad_len]

        else:
            self._print_error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º padding'–∞: {mode}")
            raise ValueError(f"Unknown padding mode: {mode}")

    def encrypt(self, data: bytes, mode: CipherMode = CipherMode.ECB,
                iv: Optional[bytes] = None, padding: PaddingMode = PaddingMode.PKCS7,
                progress_callback: Optional[Callable[[int], None]] = None) -> bytes:
        """–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –≤–∏–∑—É–∞–ª—å–Ω—ã–º –≤—ã–≤–æ–¥–æ–º"""
        print(Fore.CYAN + "\nüîê –ù–∞—á–∞–ª–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:" + Style.RESET_ALL)
        print(Fore.BLUE + f"–†–µ–∂–∏–º: {mode.name}, Padding: {padding.name}" + Style.RESET_ALL)

        if len(data) == 0:
            self._print_warning("–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –ø—É—Å—Ç—ã—Ö –¥–∞–Ω–Ω—ã—Ö")
            padded_data = self._pad_data(data, padding)
        else:
            padded_data = self._pad_data(data, padding)

        if mode != CipherMode.ECB:
            if iv is None:
                iv = self._generate_iv()
                result = bytearray(iv)
            else:
                if len(iv) != self.BLOCK_SIZE:
                    self._print_error(f"IV –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–ª–∏–Ω–æ–π {self.BLOCK_SIZE} –±–∞–π—Ç")
                    raise ValueError(f"IV must be {self.BLOCK_SIZE} bytes long")
                result = bytearray(iv)
                self._print_success(f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π IV: {self._format_key(iv)}")
        else:
            result = bytearray()

        total_blocks = len(padded_data) // self.BLOCK_SIZE
        last_progress = -1

        self._animate_loading(f"–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ {len(padded_data)} –±–∞–π—Ç ({total_blocks} –±–ª–æ–∫–æ–≤)")

        if mode == CipherMode.ECB:
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                result.extend(self.encrypt_block(block))

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.CBC:
            prev_block = iv
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                xored_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    xored_block[j] = block[j] ^ prev_block[j]

                encrypted_block = self.encrypt_block(bytes(xored_block))
                result.extend(encrypted_block)
                prev_block = encrypted_block

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.PCBC:
            prev_block = iv
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                xored_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    xored_block[j] = block[j] ^ prev_block[j]

                encrypted_block = self.encrypt_block(bytes(xored_block))
                result.extend(encrypted_block)

                next_prev = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    next_prev[j] = block[j] ^ encrypted_block[j]
                prev_block = bytes(next_prev)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.CFB:
            prev_block = iv
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                encrypted_prev = self.encrypt_block(prev_block)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = block[j] ^ encrypted_prev[j]

                result.extend(output_block)
                prev_block = bytes(output_block)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.OFB:
            register = iv
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                register = self.encrypt_block(register)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = block[j] ^ register[j]

                result.extend(output_block)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.CTR:
            counter = int.from_bytes(iv, byteorder='big')
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                counter_bytes = counter.to_bytes(self.BLOCK_SIZE, byteorder='big')

                encrypted_counter = self.encrypt_block(counter_bytes)

                output_block = bytearray(min(self.BLOCK_SIZE, len(padded_data) - i))
                for j in range(len(output_block)):
                    output_block[j] = block[j] ^ encrypted_counter[j]

                result.extend(output_block)
                counter += 1

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.RANDOM_DELTA:
            delta = iv
            for i in range(0, len(padded_data), self.BLOCK_SIZE):
                block = padded_data[i:i + self.BLOCK_SIZE]
                xored_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    xored_block[j] = block[j] ^ delta[j]

                encrypted_block = self.encrypt_block(bytes(xored_block))
                result.extend(encrypted_block)

                delta = self.encrypt_block(delta)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        else:
            self._print_error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: {mode}")
            raise ValueError(f"Unknown cypher mode: {mode}")

        encrypted_data = bytes(result)
        self._print_success(f"–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –†–µ–∑—É–ª—å—Ç–∞—Ç: {len(encrypted_data)} –±–∞–π—Ç")
        print(Fore.CYAN + "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" + Style.RESET_ALL)
        return encrypted_data

    def decrypt(self, data: bytes, mode: CipherMode = CipherMode.ECB,
                iv: Optional[bytes] = None, padding: PaddingMode = PaddingMode.PKCS7,
                progress_callback: Optional[Callable[[int], None]] = None) -> bytes:
        """–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –≤–∏–∑—É–∞–ª—å–Ω—ã–º –≤—ã–≤–æ–¥–æ–º"""
        print(Fore.CYAN + "\nüîì –ù–∞—á–∞–ª–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:" + Style.RESET_ALL)
        print(Fore.BLUE + f"–†–µ–∂–∏–º: {mode.name}, Padding: {padding.name}" + Style.RESET_ALL)

        if len(data) == 0:
            self._print_warning("–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –ø—É—Å—Ç—ã—Ö –¥–∞–Ω–Ω—ã—Ö")
            return b''

        if len(data) % self.BLOCK_SIZE != 0:
            self._print_error(f"–î–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–∞ {self.BLOCK_SIZE}")
            raise ValueError(f"Data length must be a multiple of {self.BLOCK_SIZE}")

        if mode != CipherMode.ECB and iv is None:
            iv = data[:self.BLOCK_SIZE]
            data = data[self.BLOCK_SIZE:]
            self._print_success(f"–ò–∑–≤–ª–µ—á–µ–Ω IV –∏–∑ –¥–∞–Ω–Ω—ã—Ö: {self._format_key(iv)}")

        result = bytearray()
        total_blocks = len(data) // self.BLOCK_SIZE
        last_progress = -1

        self._animate_loading(f"–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ {len(data)} –±–∞–π—Ç ({total_blocks} –±–ª–æ–∫–æ–≤)")

        if mode == CipherMode.ECB:
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                result.extend(self.decrypt_block(block))

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.CBC:
            prev_block = iv
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                decrypted_block = self.decrypt_block(block)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = decrypted_block[j] ^ prev_block[j]

                result.extend(output_block)
                prev_block = block

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.PCBC:
            prev_block = iv
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                decrypted_block = self.decrypt_block(block)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = decrypted_block[j] ^ prev_block[j]

                result.extend(output_block)

                next_prev = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    next_prev[j] = output_block[j] ^ block[j]
                prev_block = bytes(next_prev)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.CFB:
            prev_block = iv
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                encrypted_prev = self.encrypt_block(prev_block)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = block[j] ^ encrypted_prev[j]

                result.extend(output_block)
                prev_block = block

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.OFB:
            register = iv
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                register = self.encrypt_block(register)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = block[j] ^ register[j]

                result.extend(output_block)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.CTR:
            counter = int.from_bytes(iv, byteorder='big')
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                counter_bytes = counter.to_bytes(self.BLOCK_SIZE, byteorder='big')

                encrypted_counter = self.encrypt_block(counter_bytes)

                output_block = bytearray(len(block))
                for j in range(len(output_block)):
                    output_block[j] = block[j] ^ encrypted_counter[j]

                result.extend(output_block)
                counter += 1

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        elif mode == CipherMode.RANDOM_DELTA:
            delta = iv
            for i in range(0, len(data), self.BLOCK_SIZE):
                block = data[i:i + self.BLOCK_SIZE]
                decrypted_block = self.decrypt_block(block)

                output_block = bytearray(self.BLOCK_SIZE)
                for j in range(self.BLOCK_SIZE):
                    output_block[j] = decrypted_block[j] ^ delta[j]

                result.extend(output_block)

                delta = self.encrypt_block(delta)

                if progress_callback:
                    block_num = i // self.BLOCK_SIZE + 1
                    progress = int(block_num / total_blocks * 100)
                    if progress != last_progress:
                        progress_callback(progress)
                        last_progress = progress

        else:
            self._print_error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: {mode}")
            raise ValueError(f"Unknown cypher mode: {mode}")

        decrypted_data = self._unpad_data(bytes(result), padding)
        self._print_success(f"–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –†–µ–∑—É–ª—å—Ç–∞—Ç: {len(decrypted_data)} –±–∞–π—Ç")
        print(Fore.CYAN + "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" + Style.RESET_ALL)
        return decrypted_data

    @abstractmethod
    def encrypt_block(self, plaintext: bytes) -> bytes:
        pass

    @abstractmethod
    def decrypt_block(self, ciphertext: bytes) -> bytes:
        pass